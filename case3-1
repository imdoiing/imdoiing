import bluetooth
import pandas as pd
import numpy as np
import time

# 블루투스 연결 설정
device_name = "ESP32-BT-Slave"  # Arduino에서 설정한 이름
port = 1  # SPP 포트 번호

print("블루투스 장치 검색 중...")

# 블루투스 장치 검색
nearby_devices = bluetooth.discover_devices(lookup_names=True)
target_address = None

for addr, name in nearby_devices:
    print(f"발견된 장치: {name} - {addr}")
    if name == device_name:
        target_address = addr
        break

if target_address is None:
    print(f"'{device_name}' 장치를 찾을 수 없습니다.")
    print("Arduino 장치가 켜져있고 페어링되어 있는지 확인하세요.")
    exit(1)

print(f"연결 중: {device_name} ({target_address})")

# 블루투스 소켓 생성 및 연결
try:
    sock = bluetooth.BluetoothSocket(bluetooth.RFCOMM)
    sock.connect((target_address, port))
    print("블루투스 연결 성공!")
except Exception as e:
    print(f"블루투스 연결 실패: {e}")
    exit(1)

cache_path = r"C:/Users/dohyu/Desktop/capstone/r0_cache.txt"

# SOH 기준표 불러오기
df_soh = pd.read_csv(r"C:/Users/dohyu/Desktop/capstone/soh_final22.csv")
df_soh = df_soh.rename(columns={df_soh.columns[1]: 'Internal_Resistance'})
df_soh['Internal_Resistance'] = pd.to_numeric(df_soh['Internal_Resistance'], errors='coerce')

# ESP32에서 블루투스로 데이터 받기 함수
def get_sensor_data():
    while True:
        try:
            data = sock.recv(1024).decode('utf-8').strip()
            if not data:
                continue
            
            # 여러 줄이 한번에 올 수 있으므로 마지막 줄만 사용
            lines = data.split('\n')
            line = lines[-1].strip()
            
            if not line:
                continue
                
            parts = line.split(',')
            if len(parts) != 3:
                continue
            I = float(parts[0])
            V1 = float(parts[1])
            Vload = float(parts[2])
            return I, V1, Vload
        except Exception as e:
            print(f"※ 잘못된 블루투스 데이터: '{data}' → 재시도")
            continue

# SOH 및 내부저항 계산 함수 (r0은 r_input 값 그대로 사용)
def calculate_soh_and_r0(I, V1, Vload):
    r_input = (2 * V1 - Vload) / I 
    closest_row = df_soh.iloc[(df_soh['Internal_Resistance'] - r_input).abs().idxmin()]
    soh = int(closest_row['Cell_SOH'].replace('%', ''))
    r0 = round(r_input, 6)  # 기준표가 아닌 계산된 값 그대로 r0 사용
    return soh, r0, r_input

# 초기 분석: 첫 번째 데이터 기준
print(">> 초기 데이터 수신 중...")
I0, V10, Vload0 = get_sensor_data()
t0 = time.time()  # 실시간 기준 시작 시각

# 최초 SOH 및 r0 계산
soh0, r0_0, r_input0 = calculate_soh_and_r0(I0, V10, Vload0)

# r0 값 저장 (r_input 값 그대로)
with open(cache_path, 'w') as f:
    f.write(str(r0_0))

# 초기 출력
print(">> [분석 결과]")
print(f"→ I: {I0} | V1: {V10} | Vload: {Vload0}")
print(f"→ 내부저항 계산: {r_input0:.6f} Ω")
print(f"→  r₀ = {r0_0} Ω (계산값 기준) | SOH = {soh0}%")

# 사용자 명령 루프
try:
    while True:
        cmd = input("\nSOH를 갱신하려면 yes 입력 (종료: no) > ").strip().lower()
        if cmd == "no":
            print("분석 종료.")
            break
        elif cmd != "yes":
            print("잘못된 입력입니다.")
            continue
        
        # 새로운 센서 데이터 받기
        print(">> 새 데이터 수신 중...")
        I, V1, Vload = get_sensor_data()
        
        # 분석 수행
        soh, r0, r_input = calculate_soh_and_r0(I, V1, Vload)
        
        # 갱신된 r0 (r_input 기반) 저장
        with open(cache_path, 'w') as f:
            f.write(str(r0))
        
        # 결과 출력
        print(f"\n[SOH 갱신 결과]")
        print(f"→ I: {I} | V1: {V1} | Vload: {Vload}")
        print(f"→ 내부저항 계산: {r_input:.6f} Ω")
        print(f"→ r₀ = {r0} Ω (계산값 기준) | SOH = {soh}%")
except KeyboardInterrupt:
    print("\n[사용자 중단]")
finally:
    sock.close()
    print("블루투스 연결 종료")
