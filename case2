import pandas as pd
import numpy as np
import time

# 파일 경로
raw_path = r"C:/Users/dohyu/Desktop/capstone/test1.txt"
cache_path = r"C:/Users/dohyu/Desktop/capstone/r0_cache.txt"

# 경고 단계 우선순위 정의
alarm_levels = {
    '열화 시작': 1,
    '열화 가속': 2,
    '열폭주 위험 경고': 3,
    '성능 저하': 2,
    '성능 저하 가속': 3,
    '전원 차단': 4
}

# 상태 변수 초기화
path_mode = None
path_locked = False
last_alarm_level = 0


# 데이터 불러오기
df = pd.read_csv(raw_path, sep='\s+', skiprows=1, names=['Time', 'I', 'V1', 'Vload'])
df['Time'] = pd.to_numeric(df['Time'], errors='coerce')

# Time을 정수(초 단위)로 변환한 새 열 생성
df['Second'] = df['Time'].astype(int)

# 초 단위로 하나씩만 추출 (중복 제거)
df_sorted = df.drop_duplicates(subset='Second').sort_values('Time').reset_index(drop=True)

# r₀ 불러오기
for _, row in df_sorted.iterrows():
    try:
        with open(cache_path, 'r') as f:
            r0 = float(f.read().strip())  # 최신 r₀ 참조
    except Exception as e:
        print(f"[{int(row['Time'])}초] r₀ 캐시 읽기 실패: {e}")
        continue

    # 이후 r0 사용하여 mul 계산 등 진행


print(f"[기준 내부저항 r₀] = {r0} Ω")

# 경보 판단 함수
def evaluate_mul_state(mul):
    global path_mode, path_locked, last_alarm_level
    mul = round(mul, 3)

    # 정상 복귀 시 상태 초기화
    if path_locked and 0.95 < mul < 1.05:
        print("[복귀] 정상 범위로 복귀 → 경로 잠금 해제")
        path_mode = None
        path_locked = False
        last_alarm_level = 0
        return None

    # 경로 진입 조건
    if not path_locked:
        if mul >= 0.9:
            path_mode = '고온'
            path_locked = True
            last_alarm_level = alarm_levels['열화 시작']
            return '열화 시작'
        elif mul >= 1.1:
            path_mode = '저온'
            path_locked = True
            return None  # 저온 진입 자체는 경고 없음

    # 경보 단계 판단
    if path_locked:
        if path_mode == '고온':
            if 1.1 <= mul < 1.3 and last_alarm_level < alarm_levels['열화 가속']:
                last_alarm_level = alarm_levels['열화 가속']
                return '열화 가속'
            elif mul >= 1.3 and last_alarm_level < alarm_levels['열폭주 위험 경고']:
                last_alarm_level = alarm_levels['열폭주 위험 경고']
                return '열폭주 위험 경고'

        elif path_mode == '저온':
            if 1.7 <= mul < 2.5 and last_alarm_level < alarm_levels['성능 저하']:
                last_alarm_level = alarm_levels['성능 저하']
                return '성능 저하'
            elif 2.5 <= mul < 4.0 and last_alarm_level < alarm_levels['성능 저하 가속']:
                last_alarm_level = alarm_levels['성능 저하 가속']
                return '성능 저하 가속'
            elif mul >= 4.0 and last_alarm_level < alarm_levels['전원 차단']:
                last_alarm_level = alarm_levels['전원 차단']
                return '전원 차단'

    return None

# 데이터 불러오기 및 정수초 필터링
df = pd.read_csv(raw_path, sep='\s+', skiprows=1, names=['Time', 'I', 'V1', 'Vload'])
df['Time'] = pd.to_numeric(df['Time'], errors='coerce')
df['RoundedTime'] = df['Time'].round(6)
df_int = df[np.isclose(df['RoundedTime'] % 1, 0, atol=1e-6)]
df_sorted = df_int.drop_duplicates(subset='RoundedTime').sort_values('RoundedTime')

# 실시간 출력 루프
print("\n[모니터링 시작 - 1초 단위 분석]")
for _, row in df_sorted.iterrows():
    t_sec = int(row['RoundedTime'])
    I, V1, Vload = row['I'], row['V1'], row['Vload']
    if I == 0:
        print(f"[{t_sec}초] 전류=0 → 계산 불가")
        continue

    r_input = (2 * V1 - Vload) / I - 0.0048
    mul = r_input / r0
    msg = evaluate_mul_state(mul)

    print(f"[{t_sec}초] I={round(I,3)}A, V1={round(V1,3)}V, Vload={round(Vload,3)}V → R_in={round(r_input,6)}Ω, mul={round(mul,4)}", end='')
    if msg:
        print(f" → [경고] {msg}")
    else:
        print()
    time.sleep(1)
